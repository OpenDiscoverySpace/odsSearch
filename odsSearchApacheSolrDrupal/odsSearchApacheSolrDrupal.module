<?php

/**
* This function checks if the logo is correct and it can be used as a valid image for
* an educational resource in the search results page (see search-result.tpl.php).
*/
function odsSearchApacheSolrDrupal_url_exists($logo){
  $ch = @curl_init($url);
  @curl_setopt($ch, CURLOPT_HEADER, TRUE);
  @curl_setopt($ch, CURLOPT_NOBODY, TRUE);
  @curl_setopt($ch, CURLOPT_FOLLOWLOCATION, FALSE);
  @curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
  $status = array();
  preg_match('/HTTP\/.* ([0-9]+) .*/', @curl_exec($ch) , $status);
  return ($status[1] == 200);
}

/**
* This hook prepares the query by adding parameters, sorts, etc.
* We use the hook to add and remove filters in order to sort the search results.
* @param object $query: An object implementing DrupalSolrQueryInterface. No need for &.
*/
function odsSearchApacheSolrDrupal_apachesolr_query_prepare($query){

    //Update the "Sort by" block.
    //We add the Most comments sorting option (we must add this field to the schema.xml file).
    $query->setAvailableSort('comment_count', array('title' => t("Most comments"), 'default' => 'desc'));
    //Update date.
    //This field is defined in the schema.xml file.
    $query->setAvailableSort('updated', array('title' => t("Date"), 'default' => 'desc'));
	//Author fullname: the responsible of the resource.
    //This field is defined in the schema.xml file.
	$query->setAvailableSort('author', array('title' => t("Contributor"), 'default' => 'asc'));
    //Repository.
    //This field is defined in the schema.xml file.
	$query->setAvailableSort('source', array('title' => t("Repository"), 'default' => 'asc'));
    //Aggregation level.
    //This field is defined in the schema.xml file.
	$query->setAvailableSort('granularity', array('title' => t("Granularity"), 'default' => 'asc'));
    //Type: Node, page...
	$query->removeAvailableSort('bundle');
	//Author: creator of the node.
	$query->removeAvailableSort('sort_name');
    //Time the node was published.
    $query->removeAvailableSort('ds_created');

}

/**
* This hook alters the query after it's prepared and cached. 
* Any module performing a search should call drupal_alter('apachesolr_query', $query). 
* That function then invokes this hook. It allows modules to modify the query object and its parameters.
* We use this hook to include the params that we need in order to show them in the search results page or  
* for the sorting functionality.
* @param object $query: An object implementing DrupalSolrQueryInterface. No need for &.
*/
function odsSearchApacheSolrDrupal_apachesolr_query_alter($query) {
    global $user, $language;
    // returned fields
    $b= $query->getParams();
    $a = $b['fl'];
    $a[]="updated";
    $a[]="author";
    $a[]="source";
    $a[]="granularity";
    $a[]="location";
    $a[]="eo_description";

    $query->addParam('fl', $a);
    $query->addParam('odsUserLang', $user->language);
    $query->addParam('odsLang', $language->language);

}

/**
* This hook builds the documents before sending them to Solr. The function is the follow-up for apachesolr_update_index.
* We use this hook to adda text-fields needed to be indexed.
*/
function odsSearchApacheSolrDrupal_apachesolr_index_document_build(ApacheSolrDocument $document, $entity, $entity_type, $env_id) {
    try {

        //Author fullname.
        $document->addField("author",  $entity->field_author_fullname['und'][0]['value']);

        //Data provider (repository name)
        //Get taxonomy term name from tid
        $dataProvider_tid = $entity->field_data_provider['und'][0]['tid'];
        $term = taxonomy_term_load($dataProvider_tid);
        $name = $term->name;
        $document->addField("source",  $name);
	
        //Granularity
        //Get taxonomy term name from tid
        $granularity_tid = $entity->field_aggregation_level['und'][0]['tid'];
        $term = taxonomy_term_load($granularity_tid);
        $name = $term->name;
        $document->addField("granularity",  $name);

        //Get the technical location of the resource
        $document->addField("location", $entity->field_resource_link['und'][0]['url']);

        //Indexing the description in all languages
        $indexerLanguages= array('en','nl','fr','de','el','it','es','hr','bg','da','fi','et', 'lv', 'lt', 'pt','sr','ga','cs','hu','pl','ro', 'ru','sv');
        $document->addField("loid",  $entity->field_lo_identifier['und'][0]['value']);
        foreach($indexerLanguages as $lang){
            $document->addField("i18n_content_".$lang,  $entity->field_eo_description[$lang][0]['value']);
        }
        //Get the description of the resource.
        //First, we check if we have a description with the same language of the portal.
        global $language;
        //We assume that we will have always a site language.
        $site_language = $language->language;
        $description = $entity->field_eo_description[$site_language][0]['value'];
        if ($description != NULL) {
            $document->addField("eo_description", $description);
        } else {
            //We don't have a title with the same language of the portal, then we check if
            //we have a description with the same language of the node.
            $node_language = $entity->language;
            if ($node_language != NULL) {
                $description = $entity->field_eo_description[$node_language][0]['value'];
                if ($description != NULL){
                    $document->addField("eo_description", $description);
                }
            }
            if ($description == NULL){            
                //The node language is null or we don't have description with the same language of the node, 
                //then we have to check if we have a description in some language (we get the language of the field).
                //$description_language will that the value of 'und' when the $entity does not have any
                //description in any language.
                $description_language = field_language('node', $entity, 'field_eo_description');
                $description = $entity->field_eo_description[$description_language][0]['value'];
                if ($description != NULL) {
                    $document->addField("eo_description", $description);
                } else {                        
                    //We don't have the description in any language. Therefore, we will display a message 
                    //remarking this situation.
                    $document->addField("eo_description", "There is no available description for this resource");
                }
            }
        }
    } catch(Exception $x) {
        dd("Exception at indexing: " .$x);
    }
 }

// FACET HOOKS
/**
 * Implements hook_facetapi_facet_info.
 * @param array $searcher_info
 * @return array
 **/
function odsSearchApacheSolrDrupal_facetapi_facet_info(array $searcher_info) {
    $facets = array();
    // Facets are usually associated with the type of content stored in the index.
    //dd("searchers: ".print_r($searcher_info, true));
    if (isset($searcher_info['types']['node'])) {
        $facets['author'] = array(
            'name' => 'author',
            'label' => t('Author Fullname'),
            'description' => t('The author that created the resource (not the node).'),
            'field' => 'author',
            'dependency plugins' => array('role'), // ???
            'default widget' => 'links',
            'allowed operators' => array(FACETAPI_OPERATOR_AND => TRUE, FACETAPI_OPERATOR_OR => TRUE),
            'facet missing allowed' => FALSE,
            'facet mincount allowed' => FALSE,
            //'map callback' => 'mymodulename_map_im_products_nid',
            'max callback' => FALSE,
            'default sorts' => array(
                array('active', SORT_DESC),
                array('count', SORT_DESC),
                array('display', SORT_ASC),
            ),
        );
    }
    return $facets;
}

// css adjustments
drupal_add_css( drupal_get_path('module', 'odsSearchApacheSolrDrupal') . '/odsSearchApacheSolrDrupal.css', array('every_page' =>FALSE));
 
